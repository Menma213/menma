"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RankTopClient = void 0;
const axios_1 = __importDefault(require("axios"));
const events_1 = require("events");
class RankTopClient extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.api = axios_1.default.create({
            baseURL: config.baseURL || 'https://rank.top/api',
            headers: {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            },
        });
    }
    ;
    async postStats(stats, botId, authorization) {
        const response = await this.api.post(`/bots/${botId}/post`, { ...stats, authorization });
        return response.data;
    }
    ;
    async startAutopost(config, disableStats = {}) {
        const client = config?.client;
        if (!client) {
            return console.error('[Rank.top Autoposter] Client is not defined');
        }
        ;
        // Stop any existing autoposter
        if (this.autopostHandler) {
            this.stopAutopost();
        }
        ;
        const postStats = async () => {
            // Prepare stats
            const stats = {
                serverCount: disableStats.serverCount ? undefined
                    : client.guilds?.cache?.size || undefined,
                userCount: disableStats.userCount ? undefined
                    : client.users?.cache?.size || undefined,
                ping: disableStats.ping ? undefined
                    : client.ws?.ping || undefined,
                memory: disableStats.memory ? undefined
                    : (Math.round(process.memoryUsage().heapUsed / 1024 / 1024)) || undefined,
            };
            // Fetch Slash Commands
            if (!disableStats.commands) {
                const commands = await client.application?.commands?.fetch?.();
                if (commands?.map) {
                    stats.commands = commands.map((command) => ({
                        id: command.id,
                        name: command.name,
                        description: command.description,
                        options: command.options.map((option) => ({
                            type: option.type,
                            name: option.name,
                            description: option.description,
                            required: option.required,
                            choices: option.choices?.map((choice) => ({
                                name: choice.name,
                                value: choice.value
                            })),
                            options: option.options?.map((subOption) => ({
                                type: subOption.type,
                                name: subOption.name,
                                description: subOption.description,
                                required: subOption.required,
                                choices: subOption.choices?.map((choice) => ({
                                    name: choice.name,
                                    value: choice.value
                                }))
                            }))
                        }))
                    }));
                }
                ;
            }
            ;
            try {
                const response = await this.postStats(stats, client.user.id, config.authorization);
                if (response?.success) {
                    this.emit('autoposter/posted', stats);
                }
                else {
                    this.emit('autoposter/error', response?.message || 'Unknown error');
                }
                ;
            }
            catch (error) {
                this.emit('autoposter/error', error);
            }
            ;
        };
        // Wait 1 minute
        await new Promise(resolve => setTimeout(resolve, 60 * 1000));
        let started = false;
        const post = async () => {
            started = true;
            // Post stats immediately
            await postStats();
            // Set up interval for future posts
            const interval = Math.max(5 * 60, (config.interval || 30 * 60)) * 1000;
            this.autopostHandler = setInterval(postStats, interval);
        };
        client.on('ready', post);
        if (client.isReady() && !started) {
            setTimeout(() => {
                if (!started)
                    post();
            }, 5000);
        }
        ;
    }
    ;
    stopAutopost() {
        if (this.autopostHandler) {
            clearInterval(this.autopostHandler);
            this.autopostHandler = undefined;
            this.emit('autoposter/stopped');
        }
        ;
    }
    ;
}
exports.RankTopClient = RankTopClient;
;
